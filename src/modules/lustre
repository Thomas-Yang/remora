#!/bin/sh
#
#========================================================================
# HEADER
#========================================================================
#% DESCRIPTION
#% lustre
#%
#% DO NOT call this script directly. This is called by REMORA
#%
#========================================================================
#- IMPLEMENTATION
#-      version     REMORA 1.4
#-      authors     Carlos Rosales (carlos@tacc.utexas.edu)
#-                  Antonio Gomez  (agomez@tacc.utexas.edu)
#-      license     MIT
#
#========================================================================
#  HISTORY
#       2015/12/08: Initial commit
#========================================================================

# All the functions take two arguments:
#  1.- The name of the node where this function is running
#  2.- The full path where the output will be stored/read

init_module_lustre()
{
    rm -f $2/lustre*
    if [ "$REMORA_SYMMETRIC" == "0" ]; then
        if [ "$REMORA_MODE" = "FULL" ]; then
            #Capture the "internal" names (IFSNAMES) of the lustre filesystems
            #and the names of the mounts (FSNAMES)
            FSS=`df --type=lustre -P | uniq`
            local MOUNTS=()
            local idx=0; local hdx=0
            IFSNAMES=()
            FSNAMES=()
            HEADER=()
            HEADER[$hdx]=`echo TIMESTAMP`
            hdx=$((hdx+1))
            while read -r line; do
                if [ $idx == 0 ]; then
                    idx=$((idx+1))
                    continue
                fi
                IFSNAMES[$idx-1]=`echo $line  | sed 's/.*:\///' | awk '{print $1;}'`
                local TEMP=`echo $line | sed 's/.*:\///' | awk '{print $6;}'`
                FSNAMES[$idx-1]=`echo "${TEMP////}"`
                HEADER[$hdx]=`echo "${FSNAMES[$idx-1]}-RQ"`
                HEADER[$hdx+1]=`echo "${FSNAMES[$idx-1]}-RD"`
                HEADER[$hdx+2]=`echo "${FSNAMES[$idx-1]}-WR"`
                if [ "$REMORA_VERBOSE" == "1" ]; then
                    echo ${IFSNAMES[$idx-1]} ${FSNAMES[$idx-1]}
                fi
                idx=$((idx+1))
                hdx=$((hdx+3))
            done <<< "$FSS"

            printf "%-17s"  "${HEADER[@]}" >> $2/lustre_$1.txt
            printf "\n"  >> $2/lustre_$1.txt
        fi
    fi
}

collect_data_lustre()
{
# Here we use lustre stat files, which are user-readable
# We use req_waittime rather than req_active becasue empirical testing 
# indicates that IOPS are more accurately reported by this counter.
#
# Most entries are like this:
# {name of statistic} {count of events} samples [{units}] {minimum value} {maximum value} {sum of values}
# But some include an extra element:
# {name of statistic} {count of events} samples [{units}] {minimum value} {maximum value} {sum of values} {sum of value squared}
#
# cat /proc/fs/lustre/mdc/home*/stats
# snapshot_time             1452890000.568766 secs.usecs
# req_waittime              3851885 samples [usec] 37 49056921 800336413 2410726275303557
#
# cat /proc/fs/lustre/llite/home*/stats
# snapshot_time             1452890065.50567 secs.usecs
# read_bytes                1364393 samples [bytes] 1 4194304 336228258590
# write_bytes               7771 samples [bytes] 1 315502 5346139

    if [ "$REMORA_SYMMETRIC" == "0" ]; then
        if [ "$REMORA_MODE" = "FULL" ]; then
            local LUSTRE_DIR_PATH=/proc/fs/lustre
            local TIMESTAMP=`date +%s`
            local idx=0
            local COUNTER=()
            col_id=0
            for fs in "${IFSNAMES[@]}"
            do
                if [ "$REMORA_VERBOSE" == "1" ]; then
                    echo "cat /proc/fs/lustre/mdc/$fs*/stats | grep req_waittime | awk '{print $2;}' | paste -sd+ | bc"
                    echo "cat /proc/fs/lustre/llite/$fs*/stats | grep read_bytes | awk '{print $7;}' | paste -sd+ | bc"
                    echo "cat /proc/fs/lustre/llite/$fs*/stats | grep write_bytes | awk '{print $7;}' | paste -sd+ | bc"
                fi
                COUNTER[$col_id]=`cat /proc/fs/lustre/mdc/$fs*/stats | grep req_waittime | awk '{print $2;}' | paste -sd+ | bc`
                COUNTER[$((col_id+1))]=`cat /proc/fs/lustre/llite/$fs*/stats | grep read_bytes | awk '{print $7;}' | paste -sd+ | bc`
                COUNTER[$((col_id+2))]=`cat /proc/fs/lustre/llite/$fs*/stats | grep write_bytes | awk '{print $7;}' | paste -sd+ | bc`
		col_id=$((col_id+3))
            done
            # This will have TIMESTAMP FS1_IOPS FS1_READ FS1_WRITE FS2_IOPS FS2_READ FS2_WRITE ....
            # in raw counters, not rates
            printf "%-17d %-17d" $TIMESTAMP "${COUNTER[@]}" >> $2/lustre_$1.txt
            printf "\n"  >> $2/lustre_$1.txt
        fi
    fi
}

# This function might perform some processing on the data.
# If nothing needs to be done, it can be empty (but declared)
process_data_lustre()
{
  :
}

finalize_module_lustre()
{
  REMORA_NODE_ID=$3
  if [ "$REMORA_NODE_ID" == "0" ]; then 
    # Get names from lustre.txt file headers
    FSS=`df --type=lustre -P | uniq`
    local idx=0
    FSNAMES=()
    while read -r line; do
      if [ $idx == 0 ]; then
        idx=$((idx+1))
        continue
      fi  
      local TEMP=`echo $line | sed 's/.*:\///' | awk '{print $6;}'`
      FSNAMES[$idx-1]=`echo "${TEMP////}"`
      idx=$((idx+1))
    done <<< "$FSS"

    # Identify shortest entry
    min_len=0
    for file in `ls $2/lustre_*.txt`; do
       fs_col=2; len=0
       for FS in "${FSNAMES[@]}"; do
         len=`cat $file | tr -s ' ' | cut -d ' ' -f $fs_col | wc -l | awk '{print $1}'`
         if [ "$min_len" -eq "0" ] || [ "$len" -lt "$min_len" ]; then 
           min_len=$len
         fi
         fs_col=$((fs_col+3))
       done
     done
   
    # Generate file with aggregate counts from all nodes
    awk 'FNR>1 {a[FNR]=$1; for (j=2; j<=NF; j++) fs1[FNR,j]+=$j;} END {for (i=2; i<=FNR; i++){ printf "%d ",a[i]; for (j=2; j<=NF; j++){ printf "%d ",fs1[i,j]} printf "\n"} }' $2/lustre_*.txt > $2/lustre.tmp
    col_id=2
    for FS in "${FSNAMES[@]}"; do
      cut -d ' ' -f 1,$col_id,$((col_id+1)),$((col_id+2)) $2/lustre.tmp > $2/lustre.$FS
      col_id=$((col_id+3))
    done
    rm $2/lustre.tmp

    # Calculate actual data rates from raw counters
    # $1 = time; $2 = iopsi (usec); $3 = read (bytes); $4 = write (bytes)
    min_len=$((min_len-1))
    local d1=(); local d2=()
    for file in `ls $2/lustre.*`; do
      for i in `seq 1 $min_len`; do
        next=$((i+1))
        d1=(`sed "${i}q;d" $file | awk '{ print $1 " " $2 " " $3 " " $4}'`)
        d2=(`sed "${next}q;d" $file | awk '{ print $1 " " $2 " " $3 " " $4 }'`)
        fsio=`echo "scale=6; ( ${d2[1]} - ${d1[1]} ) / ( ( ${d2[0]} - ${d1[0]} ) )" | bc`
        fsrd=`echo "scale=6; ( ${d2[2]} - ${d1[2]} ) / ( 1000000.0 * ( ${d2[0]} - ${d1[0]} ) )" | bc`
        fswr=`echo "scale=6; ( ${d2[3]} - ${d1[3]} ) / ( 1000000.0 * ( ${d2[0]} - ${d1[0]} ) )" | bc`
        printf "%-17d %-17f %-17f %-17f\n" ${d1[0]} $fsio $fsrd $fswr >> $file.rate
      done
    done
  fi
}


store_data_db_lustre() {
  # Store data in the db
    jobid=$REMORA_JOB_ID
    local files=($2/lustre_*.txt)
    local prefix="$2/lustre"
    for file in "${files[@]}"; do
        local idx=0
        while IFS='' read -r line || [[ -n "$line" ]]; do
            if [ $idx = 0 ]; then
                idx=1
                continue;
            fi  
        done < "$file"
    done
}
